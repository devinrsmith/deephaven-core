import com.bmuschko.gradle.docker.tasks.image.DockerInspectImage
import com.bmuschko.gradle.docker.tasks.image.DockerPullImage
import org.gradle.initialization.BuildRequestMetaData

import java.time.Instant
import java.time.temporal.ChronoUnit

plugins {
    id 'com.bmuschko.docker-remote-api'
}

evaluationDependsOn ':deephaven-jpy'
evaluationDependsOn ':Integrations'
evaluationDependsOn ':grpc-api-server-native'

def dockerContext = project.layout.buildDirectory.dir('context')
def commonDir = rootProject.layout.projectDirectory.dir('docker/common')

def deephavenJpyWheel = project(':deephaven-jpy').tasks.getByName('buildDockerForWheel')
def deephavenWheel = project(':Integrations').tasks.getByName('buildDockerForWheel')
def deephaven2Wheel = project(':Integrations').tasks.getByName('buildDockerForWheel2')
def grpcApiTar = project(':grpc-api-server-native').tasks.getByName('distTar')

def prepareDocker = project.tasks.register('prepareDocker', Sync) {
    it.from (commonDir) {
        into 'common'
    }
    it.from (grpcApiTar.outputs.files) {
        rename { file -> 'server.tar' }
        into 'server'
    }
    it.from 'src/main/docker'
    it.into dockerContext
}

def startTime = Instant.ofEpochMilli(project.gradle.services.get(BuildRequestMetaData.class).getStartTime())
def startTimeHour = startTime.truncatedTo(ChronoUnit.HOURS)
def skipPull = project.hasProperty('deephaven.skip-pull') ?
        project.property('deephaven.skip-pull') == 'true' : false

def pullImage = { String name, String imageName ->
    project.tasks.register(name, DockerPullImage) {
        onlyIf {
            !project.gradle.startParameter.offline && !skipPull
        }
        image.set imageName
        inputs.property 'startTimeHour', startTimeHour
        outputs.files project.layout.buildDirectory.file("${imageName}.pulled") // fake output, so we can cache task
        //platform.set 'linux/amd64'
    }
}

def checkImage = { Object pullImageTask, String name, String imageName, String propertyName ->
    project.tasks.register(name, DockerInspectImage) {
        def checkImageFile = project.layout.buildDirectory.file(imageName)
        outputs.files checkImageFile
        outputs.upToDateWhen { false }
        dependsOn pullImageTask
        imageId.set imageName
        onNext { message ->
            checkImageFile.get().asFile.text = "${propertyName}=${message.repoDigests.get(0)}"
        }
    }
}

def buildImage = { TaskProvider<? extends Task> checkImageTask, String name, String baseImage, String outImage ->
    Docker.registerDockerImage(project, name) {
        dependsOn prepareDocker
        inputs.files deephavenJpyWheel.outputs.files
        inputs.files deephavenWheel.outputs.files
        inputs.files deephaven2Wheel.outputs.files
        inputs.files checkImageTask.get().outputs.files
        inputDir.set dockerContext
        // TODO: we don't have to explicitly set this if we use buildx
        buildArgs.put('TARGETARCH', 'amd64')
        buildArgs.put('BASE', baseImage)
        images.add(outImage)
    }
}

def baseImagePropertyName = { String type ->
    "deephaven.server${type}.baseImage"
}

def buildImageType = { String type ->
    def propertyName = baseImagePropertyName(type)
    def baseImage = project.property(propertyName) as String
    def pullImageTask = pullImage("pullImage${type}", baseImage)
    def checkImageTask = checkImage(pullImageTask, "checkImage${type}", baseImage, propertyName)
    return buildImage(checkImageTask, "buildImage${type}", baseImage, "deephaven/server${type}:local-build")
}

def types = [ '', '-nltk', '-pytorch', '-sklearn', '-tensorflow' ]

def builds = types.collect { buildImageType(it) }

project.tasks.register('stampProperties') {
    def checkTasks = types.collect {project.tasks.getByName("checkImage${it}") }
}

assemble.dependsOn builds