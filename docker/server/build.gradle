import com.bmuschko.gradle.docker.tasks.image.DockerInspectImage
import com.bmuschko.gradle.docker.tasks.image.DockerPullImage
import org.gradle.initialization.BuildRequestMetaData

import java.time.Instant
import java.time.temporal.ChronoUnit

plugins {
    id 'com.bmuschko.docker-remote-api'
}

evaluationDependsOn ':deephaven-jpy'
evaluationDependsOn ':Integrations'
evaluationDependsOn ':grpc-api-server-native'

def dockerContext = project.layout.buildDirectory.dir('context')
def commonDir = rootProject.layout.projectDirectory.dir('docker/common')

def deephavenJpyWheel = project(':deephaven-jpy').tasks.getByName('buildDockerForWheel')
def deephavenWheel = project(':Integrations').tasks.getByName('buildDockerForWheel')
def deephaven2Wheel = project(':Integrations').tasks.getByName('buildDockerForWheel2')
def grpcApiTar = project(':grpc-api-server-native').tasks.getByName('distTar')

def useBase = project.property('deephaven.server.useBase') == 'true'

enum PullMode {
    // When doing local development against own images
    never,

    // When wanted to grab the latest from
    always,
    cached
}

def pullMode = project.hasProperty('deephaven.server.pullMode') ?
    PullMode.valueOf((String)project.property('deephaven.server.pullMode')) :
    project.gradle.startParameter.offline ?
        PullMode.never :
        PullMode.cached

def prepareDocker = project.tasks.register('prepareDocker', Sync) {
    it.from (commonDir) {
        into 'common'
    }
    it.from (grpcApiTar.outputs.files) {
        rename { file -> 'server.tar' }
        into 'server'
    }
    it.from 'src/main/docker'
    it.into dockerContext
}

def startTime = Instant.ofEpochMilli(project.gradle.services.get(BuildRequestMetaData.class).getStartTime())
def startTimeHour = startTime.truncatedTo(ChronoUnit.HOURS)

def pullImage = { String name, String imageName ->
    project.tasks.register(name, DockerPullImage) {
        onlyIf {
            pullMode != PullMode.never
        }
        image.set imageName
        inputs.property 'startTimeHour', startTimeHour
        if (pullMode == PullMode.cached) {
            // fake output, so we can cache task
            outputs.files project.layout.buildDirectory.file("${imageName}.pulled")
        }
        //platform.set 'linux/amd64'
    }
}

def checkImage = { Object pullImageTask, String name, String imageName, String propertyName ->
    project.tasks.register(name, DockerInspectImage) {
        def checkImageFile = project.layout.buildDirectory.file("inspect/${imageName}")
        outputs.files checkImageFile
        outputs.upToDateWhen { false }
        dependsOn pullImageTask
        imageId.set imageName
        onNext { message ->
            checkImageFile.get().asFile.text = message.repoDigests.isEmpty() ? imageName : message.repoDigests.get(0)
        }
    }
}

def buildImage = { TaskProvider<? extends Task> checkImageTask, String name, String imageName, String outImage ->
    Docker.registerDockerImage(project, name) {
        dependsOn prepareDocker
        inputs.files deephavenJpyWheel.outputs.files
        inputs.files deephavenWheel.outputs.files
        inputs.files deephaven2Wheel.outputs.files
        inputs.files checkImageTask.get().outputs.files
        inputDir.set dockerContext
        // TODO: we don't have to explicitly set this if we use buildx
        buildArgs.put('TARGETARCH', 'amd64')
        buildArgs.put('BASE', imageName)
        images.add(outImage)
    }
}

def basePropertyName = { String type ->
    "deephaven.server${type}.base"
}

def specificPropertyName = { String type ->
    "deephaven.server${type}.specific"
}

def buildImageType = { String type ->
    def propertyName = useBase ? basePropertyName(type) : specificPropertyName(type)
    def imageName = project.property(propertyName) as String
    def pullImageTask = pullImage("pullImage${type}", imageName)
    def checkImageTask = checkImage(pullImageTask, "checkImage${type}", imageName, propertyName)
    return buildImage(checkImageTask, "buildImage${type}", imageName, "deephaven/server${type}:local-build")
}

def types = [ '', '-nltk', '-pytorch', '-sklearn', '-tensorflow' ]

def builds = types.collect { buildImageType(it) }

assemble.dependsOn builds

if (useBase) {
    project.tasks.register('stampSpecific') { task ->
        def inputFiles = types.collectEntries { [(it): project.tasks.getByName("checkImage${it}").outputs.files] } as Map<String, FileCollection>
        def outputFile = project.layout.buildDirectory.file('stamped.properties')
        inputs.files inputFiles.values()
        outputs.files outputFile
        doLast {
            def images = inputFiles.keySet().collect { type -> "${basePropertyName(type)}=${project.property(basePropertyName(type))}" }.join('\n')
            def digests = inputFiles.collect { e -> "${specificPropertyName(e.key)}=${e.value.singleFile.text}" }.join('\n')
            outputFile.get().asFile.text = images + '\n\n' + digests
        }
    }
}